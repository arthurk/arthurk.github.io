<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="Arthur Koziel">
  <title>Generating Ethereum Addresses in Python</title>
  <link rel="alternate" type="application/rss+xml" title="RSS" href="https://www.arthurkoziel.com/feed.xml">
  <style>
  /* light theme for mobile screens,
     dark theme and laptop/desktop overrides at bottom */
  body {
    font-family: Helvetica, Arial, "Liberation Sans", sans-serif;
    font-weight: 400;
    font-size: 1rem;
    line-height: 1.25;
    max-width: 630px;
    margin: 0 15px;
    background-color: #fff;
    color: #0b0c0c;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-transform: none;
    overflow-wrap: break-word;
    word-wrap: break-word;
    margin-bottom: 50px;
  }

  /* links */
  a { color: #1d70b8 }
  a:hover { color: #003078 }

  /* main heading and date */
  nav {
    margin-bottom: 30px;
  }

  /* headings */
  h1, h2, h3 {
    color: #202124;
    font-weight: 700;
    margin-top: 0;
  }

  h1 {
    font-size: 2rem;
    line-height: 1.09;
    margin-bottom: 30px;
  }

  h2 {
    font-size: 1.5rem;
    line-height: 1.05;
    margin-bottom: 20px;
  }

  h3 {
    font-size: 1.125rem;
    line-height: 1.11;
    margin-bottom: 15px;
  }

  /* date below main heading */
  #date {
    color: #505a5f;
    font-weight: 400;
    margin-top: 0;
    margin-bottom: 15px;
  }

  /* images */
  img {
    height: auto;
    max-width: 100%;
    vertical-align: middle;
  }

  /* code */
  code, pre {
    font-size: 0.9rem;
  }

  pre {
    padding: 1rem;
    overflow: auto;
    margin: 25px 0;
  }

  /* inline code */
  article > p > code, article > ul > li > code {
    font-weight: 700;
    color: #202124;
  }

  /* tables */
  table {
    border-collapse: collapse;
    margin: 18px 0;
  }

  table tr {
    vertical-align: top;
  }

  table td {
    border-bottom: 1px solid #777;
    padding: .5em 0;
  }

  table tr:last-child td {
    border-bottom: 0;
  }

  /* first column */
  table td:nth-child(1) {
    width: 25%;
    padding-right: 1em;
    color: #777;
  }

  /* lists */
  ul, ol {
    font-size: 1rem;
    line-height: 1.25;
    margin-bottom: 15px;
    padding-left: 20px;
  }

  ul > li, ol > li {
    margin-bottom: 1em;
  }

  ul#blog-archive {
    font-size: 1rem;
    margin: 0;
    padding: 0;
  }

  ul#blog-archive li {
    list-style: none;
    margin-top: 20px;
    margin-bottom: 0;
    padding-top: 10px;
    border-top: 1px solid #b1b4b6;
  }

  ul#blog-archive li a {
    font-weight: 700;
  }

  ul#blog-archive li p {
    margin: 5px 0;
    color: #505a5f;
  }

  /*
  * Laptop/Desktop screens
  */

  @media(min-width: 48em) {
    body {
        font-size: 1.1875rem;
        line-height: 1.31;
        margin-right:auto;
        margin-left: auto;
    }

    h1 {
      font-size: 3rem;
      line-height: 1.04;
    }

    h2 {
      font-size: 2.25rem;
      line-height: 1.11;
      margin-bottom: 30px;
    }

    h3 {
      font-size: 1.5rem;
      line-height: 1.25;
      margin-bottom: 20px;
    }

    ol, ul {
      font-size: 1.1875rem;
      line-height: 1.31;
      margin-bottom: 20px;
    }

    ul#blog-archive {
      font-size: 1.1875rem;
      line-height: 1.31;
    }

    ul#blog-archive li p {
      font-size: 1rem;
      line-height: 1.5
    }

    code, pre {
      font-size: 1rem;
    }
  }

  /*
  * Dark theme
  */

  @media (prefers-color-scheme: dark) {
    body {
      background-color: #202124;
      color: #bdc1c6;
    }
    h1, h2, h3 { color: #e8eaed }
    #date, ul#blog-archive li p {
      color: #bdc1c6
    }
    article > p > code, article > ul > li > code {
      color: #bdc1c6
    }
    a { color: #8ab4f8  }
    a:hover { color: #fff }
    li::marker { color: #e8eaed }
  }
</style>
</head>
<body>
<nav>
  <p>
    <a href="https://www.arthurkoziel.com/">Home</a> |
    <a href="https://www.arthurkoziel.com/blog/">Blog</a>
  </p>
</nav>


<article>
  <header>
    <h1 class="title">Generating Ethereum Addresses in Python</h1>
    <div id="date">
      <time class="date" datetime="2020-02-16">February 16, 2020</time>
    
    </div>
  </header>

  <p>I've been wondering how long it would take to generate all Ethereum private keys with addresses on my laptop.</p>
<p>I know there is <a href="https://bitcointalk.org/index.php?topic=7769.msg1010711#msg1010711">not enough energy in our star system</a> to do this in a reasonable timeframe, even on an imaginative computer that would use the absolute minimum of energy possible. This was more of a learning experience for me to get to know more about SHA-3 and KECCAK hashes, ECDSA curves, Public Keys and Ethereum addresses.</p>
<p>Due to its slow interpreter, Python is usually not a good choice when it comes to writing performant applications. The exception being Python modules which use an interface that calls C/C++ code. These modules are usually very fast, popular examples are <a href="https://www.tensorflow.org/">Tensorflow</a> and <a href="https://numpy.org/">Numpy</a>. To generate Ethereum addresses we can use the following two Python modules which are both C based and have a good performance:</p>
<ul>
<li><a href="https://github.com/ofek/coincurve/">coincurve</a>: Cross-platform Python CFFI bindings for libsecp256k1</li>
<li><a href="https://github.com/tiran/pysha3">pysha3</a>: SHA-3 wrapper for Python (with support for keccak)</li>
</ul>
<p>Generating Ethereum addresses is a 3-step process:</p>
<ol>
<li>Generate a private key</li>
<li>Derive the public key from the private key</li>
<li>Derive the Ethereum address from the public key</li>
</ol>
<p>Note that public keys and Ethereum addresses are not the same. Addresses are hashes of public keys. It's not possible to send funds to a public key.</p>
<h2 id="step-1-generate-a-private-key">Step 1: Generate a private key</h2>
<p>Ethereum private keys are based on <a href="https://keccak.team/keccak.html">KECCAK-256 hashes</a>. To generate such a hash we use the <code>keccak_256</code> function from the pysha3 module on a random 32 byte seed:</p>
<pre data-lang="python" style="background-color:#282a36;color:#f8f8f2;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#ff79c6;">import </span><span>secrets
</span><span style="color:#ff79c6;">from </span><span>sha3 </span><span style="color:#ff79c6;">import </span><span>keccak_256
</span><span>
</span><span>private_key </span><span style="color:#ff79c6;">= </span><span style="color:#50fa7b;">keccak_256</span><span>(secrets</span><span style="color:#ff79c6;">.</span><span style="color:#50fa7b;">token_bytes</span><span>(</span><span style="color:#bd93f9;">32</span><span>))</span><span style="color:#ff79c6;">.</span><span style="color:#50fa7b;">digest</span><span>()
</span></code></pre>
<p>Note that a KECCAK hash is not the same as a SHA-3 hash. KECCAK won a competition to become the SHA-3 standard but was slightly modified before it became standardized. Some SHA3 libraries such as pysha3 include the legacy KECCAK algorithm while others, such as the <a href="https://docs.python.org/3.7/library/hashlib.html">Python hashlib module</a>, only implement the official SHA-3 standard.</p>
<h2 id="step-2-derive-the-public-key-from-the-private-key">Step 2: Derive the public key from the private key</h2>
<p>To get our public key we need to sign our private key with an Elliptic Curve Digital Signature Algorithm (ECDSA). Ethereum uses the <a href="https://en.bitcoin.it/wiki/Secp256k1">secp256k1 curve ECDSA</a>. Coincurve uses this as a default so we don't need to explicitly specify it when calling the function:</p>
<pre data-lang="python" style="background-color:#282a36;color:#f8f8f2;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#ff79c6;">from </span><span>coincurve </span><span style="color:#ff79c6;">import </span><span>PublicKey
</span><span>
</span><span>public_key </span><span style="color:#ff79c6;">= </span><span>PublicKey</span><span style="color:#ff79c6;">.</span><span style="color:#50fa7b;">from_valid_secret</span><span>(private_key)</span><span style="color:#ff79c6;">.</span><span style="color:#50fa7b;">format</span><span>(</span><span style="font-style:italic;color:#ffb86c;">compressed</span><span style="color:#ff79c6;">=</span><span style="color:#bd93f9;">False</span><span>)[</span><span style="color:#bd93f9;">1</span><span>:]
</span></code></pre>
<p>The <a href="https://ethereum.github.io/yellowpaper/paper.pdf">Ethereum Yellow Paper</a> states that the public key has to be a byte array of size 64.</p>
<p>By default coincurve uses the compressed format for public keys (libsecp256k1 was developed for Bitcoin where compressed keys are commonly used) which is 33 bytes in size. Uncompressed keys are 65 bytes in size. Additionally all public keys are prepended with a single byte to indicate if they are compressed or uncompressed. This means we first need to get the uncompressed 65 byte key (<code>compressed=False</code>) and then strip the first byte (<code>[1:]</code>) to get our 64 byte Ethereum public key.</p>
<h2 id="step-3-derive-the-ethereum-address-from-the-public-key">Step 3: Derive the Ethereum address from the public key</h2>
<p>We can now generate our Ethereum address:</p>
<pre data-lang="python" style="background-color:#282a36;color:#f8f8f2;" class="language-python "><code class="language-python" data-lang="python"><span>addr </span><span style="color:#ff79c6;">= </span><span style="color:#50fa7b;">keccak_256</span><span>(public_key)</span><span style="color:#ff79c6;">.</span><span style="color:#50fa7b;">digest</span><span>()[</span><span style="color:#ff79c6;">-</span><span style="color:#bd93f9;">20</span><span>:]
</span></code></pre>
<p>As specified in the <a href="https://ethereum.github.io/yellowpaper/paper.pdf">Yellow Paper</a> we take the right most 20 bytes of the 32 byte KECCAK hash of the corresponding ECDSA public key.</p>
<h2 id="full-example">Full Example</h2>
<p>This is the full example code from the above steps. It generates a random private key, derives the address and prints them in hex format:</p>
<pre data-lang="python" style="background-color:#282a36;color:#f8f8f2;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#ff79c6;">from </span><span>secrets </span><span style="color:#ff79c6;">import </span><span>token_bytes
</span><span style="color:#ff79c6;">from </span><span>coincurve </span><span style="color:#ff79c6;">import </span><span>PublicKey
</span><span style="color:#ff79c6;">from </span><span>sha3 </span><span style="color:#ff79c6;">import </span><span>keccak_256
</span><span>
</span><span>private_key </span><span style="color:#ff79c6;">= </span><span style="color:#50fa7b;">keccak_256</span><span>(</span><span style="color:#50fa7b;">token_bytes</span><span>(</span><span style="color:#bd93f9;">32</span><span>))</span><span style="color:#ff79c6;">.</span><span style="color:#50fa7b;">digest</span><span>()
</span><span>public_key </span><span style="color:#ff79c6;">= </span><span>PublicKey</span><span style="color:#ff79c6;">.</span><span style="color:#50fa7b;">from_valid_secret</span><span>(private_key)</span><span style="color:#ff79c6;">.</span><span style="color:#50fa7b;">format</span><span>(</span><span style="font-style:italic;color:#ffb86c;">compressed</span><span style="color:#ff79c6;">=</span><span style="color:#bd93f9;">False</span><span>)[</span><span style="color:#bd93f9;">1</span><span>:]
</span><span>addr </span><span style="color:#ff79c6;">= </span><span style="color:#50fa7b;">keccak_256</span><span>(public_key)</span><span style="color:#ff79c6;">.</span><span style="color:#50fa7b;">digest</span><span>()[</span><span style="color:#ff79c6;">-</span><span style="color:#bd93f9;">20</span><span>:]
</span><span>
</span><span style="color:#8be9fd;">print</span><span>(</span><span style="color:#f1fa8c;">&#39;private_key:&#39;</span><span>, private_key</span><span style="color:#ff79c6;">.</span><span style="color:#50fa7b;">hex</span><span>())
</span><span style="color:#8be9fd;">print</span><span>(</span><span style="color:#f1fa8c;">&#39;eth addr: 0x&#39; </span><span style="color:#ff79c6;">+ </span><span>addr</span><span style="color:#ff79c6;">.</span><span style="color:#50fa7b;">hex</span><span>())
</span><span>
</span><span style="color:#6272a4;">### Output ###
</span><span style="color:#6272a4;"># private_key: 7bf19806aa6d5b31d7b7ea9e833c202e51ff8ee6311df6a036f0261f216f09ef
</span><span style="color:#6272a4;"># eth addr: 0x3db763bbbb1ac900eb2eb8b106218f85f9f64a13
</span></code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>I used the Python <code>timeit</code> module to do <a href="https://gist.github.com/arthurk/fbc876951379e2b0c889ea71b5167b4e">a quick benchmark</a> with the above code. The result is that my laptop can generate 18k addresses per second on a single cpu core. Using all 4 cpu cores that's 72k addresses per second, ~6.2 billion (6.220.800.000) addresses per day or around two trillion (2.270.592.000.000) addresses per year.</p>
<p>Ethereum's address space is 2^160. This means that by using this method it would take my laptop 643665439999999976814879449351716864 (six hundred and forty-three decillion ...) years to generate all Ethereum private keys with addresses.</p>

</article>


</body>
</html>
